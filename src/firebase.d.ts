import * as firestoreNamespace from './firestore'
import * as functionsNamespace from './functions/functions'

export namespace firebase {
  /**
   * The allowed values for LoginOptions.type.
   */
  export enum LoginType {
    /**
     * No further data is required.
     */
    ANONYMOUS,
    /**
     * This requires you to pass in the 'passwordOptions' as well.
     */
    PASSWORD,
    /**
     * This requires you to add the 'phoneOptions' as well.
     */
    PHONE,
    /**
     * This requires you to pass either an authentication token generated by your backend server
     * or the tokenProviderFn function that returns a promise to provide the token (see 'customOptions').
     * See: https://firebase.google.com/docs/auth/server
     */
    CUSTOM,
    /**
     * This requires you to setup Facebook Auth in the Firebase console,
     * as well as uncommenting the SDK includes in include.gradle (Android) and Podfile (iOS).
     * You can pass in an optional 'facebookOptions' object to override the default scopes.
     */
    FACEBOOK,
    /**
     * This requires you to setup Google Sign In in the Firebase console,
     * as well as uncommenting the SDK includes in include.gradle (Android) and Podfile (iOS).
     * You can pass in an optional 'googleOptions' object to set a 'hostedDomain'.
     */
    GOOGLE,
    /**
     * This requires you to pass in the 'emailLinkOptions' as well.
     * Note that 'Firebase Dynamic Links' must be enabled for this login type to work.
     */
    EMAIL_LINK,
    /**
     * Apple
     */
    APPLE,
    /**
     * Microsoft
     */
    MICROSOFT,
  }

  export enum LogComplexEventTypeParameter {
    STRING,
    INT,
    FLOAT,
    DOUBLE,
    LONG,
    ARRAY,
    BOOLEAN,
  }

  /**
   * The allowed values for QueryOptions.orderBy.type.
   */
  export enum QueryOrderByType {
    KEY,
    VALUE,
    CHILD,
    PRIORITY,
  }

  /**
   * The allowed values for QueryOptions.range.type.
   */
  export enum QueryRangeType {
    START_AT,
    END_AT,
    EQUAL_TO,
  }

  /**
   * The allowed values for QueryOptions.limit.type.
   */
  export enum QueryLimitType {
    FIRST,
    LAST,
  }

  export enum ServerValue {
    /**
     * When for instance using setValue you can set a timestamp property to this placeholder value.
     * Example:
     *   updateTs: firebase.ServerValue.TIMESTAMP
     */
    TIMESTAMP,
  }

  export interface MessagingOptions {
    /**
     * For Messaging, either pass in this callback function here, or use addOnMessageReceivedCallback.
     */
    onPushTokenReceivedCallback?: (token: string) => void;

    /**
     * For Messaging, either pass in this callback function here, or use addOnPushTokenReceivedCallback.
     */
    onMessageReceivedCallback?: (message: Message) => void;

    /**
     * For Messaging (Push Notifications). Whether you want this plugin to automatically display the notifications or just notify the callback.
     * Currently used on iOS only. Default true.
     */
    showNotifications?: boolean;

    /**
     * For Messaging (Push Notifications). Whether you want this plugin to always handle the notifications when the app is in foreground.
     * Currently used on iOS only. Default false.
     */
    showNotificationsWhenInForeground?: boolean;

    /**
     * Automatically clear the badges on starting.
     * Currently used on iOS only. Default true.
     */
    autoClearBadge?: boolean;
  }

  /**
   * The options object passed into the init function.
   */
  export interface InitOptions extends MessagingOptions {
    /**
     * Allow the app to send analytics data to Firebase.
     * Can also be set later with analytics.setAnalyticsCollectionEnabled.
     * Default true.
     */
    analyticsCollectionEnabled?: boolean;

    /**
     * Allow the app to collect Crashlytics data and send it to Firebase.
     * Can also be set later with crashlytics.setCrashReportingEnabled.
     * Only useful in case it was disabled in AndroidManfifest.xml and/or Info.plist,
     * see https://firebase.google.com/docs/crashlytics/customize-crash-reports
     */
    crashlyticsCollectionEnabled?: boolean;

    /**
     * Allow disk persistence. Default true for Firestore, false for regular Firebase DB.
     */
    persist?: boolean;

    /**
     * Get notified when the user is logged in.
     */
    onAuthStateChanged?: (data: AuthStateData) => void;

    /**
     * Attempt to sign out before initializing, useful in case previous
     * project token is cached which leads to following type of error:
     *   "[FirebaseDatabase] Authentication failed: invalid_token ..."
     * Default false.
     */
    iOSEmulatorFlush?: boolean;

    /**
     * For Firebase Storage you can pass in something like 'gs://n-plugin-test.appspot.com'
     * here so we can cache it. Otherwise pass in the 'bucket' param when using Storage features.
     * Can be found in the firebase console.
     */
    storageBucket?: string;

    /**
     * Get notified when a dynamic link was used to launch the app. Alternatively use addOnDynamicLinkReceivedCallback.
     * TODO iOS seems to return an object; not a string
     */
    onDynamicLinkCallback?: (data: DynamicLinkData) => void;
  }

  export interface QueryRangeOption {
    type: QueryRangeType;
    value: any;
  }

  /**
   * The options object passed into the query function.
   */
  export interface QueryOptions {
    /**
     * How you'd like to sort the query result.
     */
    orderBy: {
      type: QueryOrderByType;
      /**
       * mandatory when type is QueryOrderByType.CHILD
       */
      value?: string;
    };

    /**
     * You can further restrict the returned results by specifying restrictions.
     * Need more than one range restriction? Use 'ranges' instead.
     */
    range?: QueryRangeOption;

    /**
     * Same as 'range', but for a 'chain of ranges'.
     * You can further restrict the returned results by specifying restrictions.
     */
    ranges?: QueryRangeOption[];

    /**
     * You can limit the number of returned rows if you want to.
     */
    limit?: {
      type: QueryLimitType;
      value: number;
    };

    /**
     * Set this to true if you don't want to listen for any future updates,
     * but just want to retrieve the current value.
     * You can also use this to check if certain data is in the database.
     * Default false.
     */
    singleEvent?: boolean;
  }

  export interface GetAuthTokenOptions {
    /**
     * Default false.
     */
    forceRefresh?: boolean;
  }

  export interface IdTokenResult {
    token: string;
    claims: { [key: string]: any };
    signInProvider: string;
    expirationTime: number;
    issuedAtTime: number;
    authTime: number;
  }

  export interface Provider {
    id: string;
    token?: string;
  }

  export interface FirebasePasswordLoginOptions {
    email: string;
    password: string;
  }

  export interface FirebaseEmailLinkActionCodeSettings {
    url: string;
    iOS?: {
      bundleId: string;
    };
    android?: {
      packageName: string;
      installApp?: false;
      minimumVersion?: string;
    };
  }

  export interface FirebaseEmailLinkLoginOptions
    extends FirebaseEmailLinkActionCodeSettings {
    email: string;
  }

  export interface FirebasePhoneLoginOptions {
    phoneNumber: string;
    /**
     * The message show to the user that prompts him to enter the received verification code.
     * Default: "Verification code".
     */
    verificationPrompt?: string;
    android?: {
      /**
       * The maximum amount of time you are willing to wait for SMS auto-retrieval to be completed by the library. Maximum allowed value is 2 minutes. Use 0 to disable SMS-auto-retrieval. If you specified a positive value less than 30 seconds, library will default to 30 seconds.
       * Default: 60 (seconds)
       * See: https://firebase.google.com/docs/reference/android/com/google/firebase/auth/PhoneAuthProvider
       */
      timeout: number;
    };
  }

  export interface FirebaseGoogleLoginOptions {
    hostedDomain?: string;
    /**
     * You can add scopes like "https://www.googleapis.com/auth/contacts.readonly" and "https://www.googleapis.com/auth/user.birthday.read"
     *
     * Default: ["profile", "email"]
     */
    scopes?: Array<string>;
  }

  export interface FirebaseFacebookLoginOptions {
    /**
     * Default: ["public_profile", "email"]
     */
    scopes?: Array<string>;
  }

  export type AppleLoginScope = "name" | "email";

  export interface AppleLoginOptions {
    /**
     * Default: ["name", "email"]
     */
    scopes?: Array<AppleLoginScope>;
    /**
     * Android only.
     * Supported locales: https://developer.apple.com/documentation/signinwithapplejs/incorporating_sign_in_with_apple_into_other_platforms#3332112
     * Default: "en".
     */
    locale?: string;
  }
  
  export interface MicrosoftLoginOptions {
    /**
     * Scopes to request
     */
    scopes?: Array<string>;
    /**
     * Refer to
     * https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-auth-code-flow#request-an-authorization-code
     * for a full list of supported parameters
     */
    customParams?: { [k: string]: string };
  }

  export interface FirebaseCustomLoginOptions {
    /**
     * The JSON Web Token (JWT) to use for authentication.
     * Either specify this, or 'tokenProviderFn'.
     * See: https://firebase.google.com/docs/auth/server
     */
    token?: string;
    /**
     * A function that returns a promise with the  JSON Web Token (JWT) to use for authentication.
     * Either specify this, or 'token'.
     * See: https://firebase.google.com/docs/auth/server
     */
    tokenProviderFn?: () => Promise<String>;
  }

  export interface LoginIOSOptions {
    controller?: any;
  }

  /**
   * The options object passed into the login function.
   */
  export interface LoginOptions {
    type: LoginType;
    passwordOptions?: FirebasePasswordLoginOptions;
    emailLinkOptions?: FirebaseEmailLinkLoginOptions;
    phoneOptions?: FirebasePhoneLoginOptions;
    googleOptions?: FirebaseGoogleLoginOptions;
    facebookOptions?: FirebaseFacebookLoginOptions;
    appleOptions?: AppleLoginOptions;
    microsoftOptions?: MicrosoftLoginOptions;
    customOptions?: FirebaseCustomLoginOptions;
    ios?: LoginIOSOptions;

    /**
     * @deprecated Please use the 'passwordOptions?: FirebasePasswordLoginOptions' object instead.
     */
    email?: string;
    /**
     * @deprecated Please use the 'passwordOptions?: FirebasePasswordLoginOptions' object instead.
     */
    password?: string;
    /**
     * @deprecated Please use the 'customOptions?: FirebaseCustomLoginOptions' object instead.
     */
    token?: string;
    /**
     * @deprecated Please use the 'customOptions?: FirebaseCustomLoginOptions' object instead.
     */
    tokenProviderFn?: () => Promise<String>;
    /**
     * @deprecated Please use the 'facebookOptions?: FirebaseFacebookLoginOptions' object instead.
     */
    scope?: string[];
  }

  export interface ReauthenticateOptions {
    type: LoginType;
    passwordOptions?: FirebasePasswordLoginOptions;
    /**
     * @deprecated Please use the 'passwordOptions?: FirebasePasswordLoginOptions' object instead.
     */
    email?: string;
    /**
     * @deprecated Please use the 'passwordOptions?: FirebasePasswordLoginOptions' object instead.
     */
    password?: string;
  }

  type ActionCodeSettings = {
    url: string;
    handleCodeInApp?: boolean;
    android?: {
      installApp?: boolean;
      minimumVersion?: string;
      packageName: string;
    };
    iOS?: {
      bundleId: string;
      dynamicLinkDomain?: string;
    };
  };

  /**
   * The returned object from the login function.
   */
  export interface User {
    uid: string;
    email?: string;
    emailVerified: boolean;
    displayName?: string;
    phoneNumber?: string;
    anonymous: boolean;
    isAnonymous: boolean; // This is used by the web API
    providers: Array<Provider>;
    photoURL?: string;
    metadata: UserMetadata;
    additionalUserInfo?: AdditionalUserInfo;

    /** iOS only */
    refreshToken?: string;

    getIdToken(forceRefresh?: boolean): Promise<string>;

    getIdTokenResult(forceRefresh?: boolean): Promise<IdTokenResult>;

    sendEmailVerification(
      actionCodeSettings?: ActionCodeSettings
    ): Promise<void>;
  }

  /**
   * The metadata of the user
   */
  export interface UserMetadata {
    creationTimestamp: Date;
    lastSignInTimestamp: Date;
  }

  /**
   * Contains additional user information
   */
  export interface AdditionalUserInfo {
    profile: { [k: string]: any };
    providerId: string;
    username: string;
    isNewUser: boolean;
  }

  /**
   * The returned object from the push function.
   */
  export interface PushResult {
    key: string;
  }

  /**
   * The returned object from the addEventListener functions.
   */
  export interface AddEventListenerResult {
    path: string;
    listeners: Array<any>;
  }

  /**
   * The options object passed into the createUser function.
   */
  export interface CreateUserOptions {
    email: string;
    password: string;
  }

  /**
   * The options object passed into the updateProfile function.
   */
  export interface UpdateProfileOptions {
    displayName?: string;
    photoURL?: string;
  }

  /**
   * The returned object in the callback handlers
   * of the addChildEventListener and addValueEventListener functions.
   */
  export interface FBData {
    type: string;
    key: string;
    value: any;
  }

  export interface FBDataSingleEvent extends FBData {
    children?: Array<any>;
  }

  export interface FBErrorData {
    error: string;
  }
  
  type AuthStateDataLoggedIn = {
    loggedIn: true;
    user: User;
  }
  
  type AuthStateDataLoggedOut = {
    loggedIn: false;
    user: null;
  }

  export type AuthStateData = AuthStateDataLoggedIn | AuthStateDataLoggedOut

  export interface AuthStateChangeListener {
    onAuthStateChanged: (data: AuthStateData) => void;
    thisArg?: any;
  }

  export interface RemoteConfigProperty {
    key: string;
    default: any;
  }

  export interface GetRemoteConfigOptions {
    /**
     * The number of seconds before retrieving fresh state from the server.
     * Default 12 hours.
     */
    cacheExpirationSeconds?: number;
    /**
     * The configuration properties to retrieve for your app. Specify as:
     *  properties: [{
     *    key: "holiday_promo_enabled",
     *    default: false
     *  }, ..]
     */
    properties: Array<RemoteConfigProperty>;
  }

  /**
   * The returned object from the getRemoteConfig function.
   */
  export interface GetRemoteConfigResult {
    /**
     * The date the data was last refreshed from the server.
     * Should honor the 'cacheExpirationSeconds' you passed in previously.
     */
    lastFetch: Date;
    /**
     * The result may be throttled when retrieved from the server.
     * Even when the cache has expired. And it's just FYI really.
     */
    throttled: boolean;
    /**
     * A JS Object with properties and values.
     * If you previously requested keys ["foo", "is_enabled"] then this will be like:
     *   properties: {
     *     foo: "bar",
     *     is_enabled: true
     *   }
     */
    properties: Object;
  }

  export interface DynamicLinkData {
    url: string;
    minimumAppVersion: string;
  }

  /**
   * The returned object in the callback handler of the addOnMessageReceivedCallback function.
   *
   * Note that any custom data you send from your server will be available as
   * key/value properties on the Message object as well.
   */
  export interface Message {
    /**
     * Indicated whether or not the notification was received while the app was in the foreground.
     */
    foreground: boolean;
    /**
     * The main text shown in the notificiation.
     * Not available on Android when the notification was received in the background.
     */
    body?: string;
    /**
     * Optional title, shown above the body in the notification.
     * Not available on Android when the notification was received in the background.
     */
    title?: string;
    /**
     * Any other data you may have added to the notification.
     */
    data: any;
    /**
     * Indicates whether or not the notification was tapped.
     * iOS only.
     */
    notificationTapped?: boolean;
  }

  export function init(options?: InitOptions): Promise<any>;

  // Database
  export interface OnDisconnect {
    cancel(): Promise<any>;

    remove(): Promise<any>;

    set(value: any): Promise<any>;

    setWithPriority(value: any, priority: number | string): Promise<any>;

    update(values: Object): Promise<any>;
  }

  export interface DataSnapshot {
    key: string;
    ref: any; // TODO: Type it so that it returns a databaseReference.
    child(path: string): DataSnapshot;

    exists(): boolean;

    forEach(action: (snapshot: DataSnapshot) => any): boolean;

    getPriority(): string | number | null;

    hasChild(path: string): boolean;

    hasChildren(): boolean;

    numChildren(): number;

    toJSON(): Object;

    val(): any;
  }

  export interface FirebaseQueryResult {
    type: string;
    key: string;
    value: any;
  }

  export type Unsubscribe = () => void;

  export namespace dynamicLinks {
    export enum MATCH_CONFIDENCE {
      WEAK,
      STRONG,
    }

    export interface DynamicLinkCallbackData {
      url: string;
      matchConfidence?: MATCH_CONFIDENCE;
      minimumAppVersion?: string;
    }
  }
  // Auth
  export function login(options: LoginOptions): Promise<User>;

  export function reauthenticate(options: ReauthenticateOptions): Promise<User>;

  export function reloadUser(): Promise<void>;

  export function getAuthToken(
    option: GetAuthTokenOptions
  ): Promise<IdTokenResult>;

  export function logout(): Promise<any>;

  export function unlink(providerId: string): Promise<User>;

  export function fetchSignInMethodsForEmail(
    email: string
  ): Promise<Array<string>>;

  export function sendEmailVerification(
    actionCodeSettings?: ActionCodeSettings
  ): Promise<any>;

  export function createUser(options: CreateUserOptions): Promise<User>;

  export function deleteUser(): Promise<any>;

  export function updateProfile(options: UpdateProfileOptions): Promise<any>;

  export function sendPasswordResetEmail(email: string): Promise<void>;

  export function updateEmail(newEmail: string): Promise<void>;

  export function updatePassword(newPassword: string): Promise<void>;

  export function addAuthStateListener(
    listener: AuthStateChangeListener
  ): boolean;

  export function removeAuthStateListener(
    listener: AuthStateChangeListener
  ): boolean;

  export function hasAuthStateListener(
    listener: AuthStateChangeListener
  ): boolean;

  export function getCurrentUser(): Promise<User>;

  // Messaging
  export function addOnMessageReceivedCallback(
    onMessageReceived: (data: Message) => void
  ): Promise<any>;

  export function addOnPushTokenReceivedCallback(
    onPushTokenReceived: (data: string) => void
  ): Promise<any>;

  export function registerForInteractivePush(model: any): void;

  export function getCurrentPushToken(): Promise<string>;

  export function registerForPushNotifications(
    options?: MessagingOptions
  ): Promise<void>;

  export function unregisterForPushNotifications(): Promise<void>;

  export function subscribeToTopic(topicName): Promise<any>;

  export function unsubscribeFromTopic(topicName): Promise<any>;

  export function areNotificationsEnabled(): boolean;

  // dynamic links
  export function addOnDynamicLinkReceivedCallback(
    onDynamicLinkReceived: (
      callBackData: dynamicLinks.DynamicLinkCallbackData
    ) => void
  ): Promise<any>;

  // remote config
  export function getRemoteConfig(
    options: GetRemoteConfigOptions
  ): Promise<GetRemoteConfigResult>;

  export function transaction(
    path: string,
    transactionUpdate: (a: any) => any,
    onComplete?: (
      error: Error | null,
      committed: boolean,
      dataSnapshot: DataSnapshot
    ) => any
  ): Promise<any>;

  export function push(path: string, value: any): Promise<PushResult>;

  export function getValue(path: string): Promise<any>;

  export function setValue(path: string, value: any): Promise<any>;

  export function update(path: string, value: any): Promise<any>;

  export function remove(path: string): Promise<any>;

  export function query(
    onValueEvent: (data: FBData | FBErrorData) => void,
    path: string,
    options: QueryOptions
  ): Promise<any>;

  export function addChildEventListener(
    onChildEvent: (data: FBData) => void,
    path: string
  ): Promise<AddEventListenerResult>;

  export function addValueEventListener(
    onValueEvent: (data: FBData) => void,
    path: string
  ): Promise<AddEventListenerResult>;

  export function removeEventListeners(
    listeners: Array<any>,
    path: string
  ): Promise<any>;

  export function onDisconnect(path: string): OnDisconnect;

  export function enableLogging(
    logger?: boolean | ((a: string) => any),
    persistent?: boolean
  );

  /**
   * Tells the client to keep its local cache in sync with the server automatically.
   */
  export function keepInSync(path: string, switchOn: boolean): Promise<any>;

  export namespace functions {
    export function httpsCallable<I, O>(
      callableFunctionName: string,
      region?: functionsNamespace.SupportedRegions
    ): functionsNamespace.HttpsCallable<I, O>;

    export function useFunctionsEmulator(origin: string): void;
  }

  export namespace firestore {
    export class FieldPath {
      /**
       * Creates a FieldPath from the provided field names. If more than one field
       * name is provided, the path will point to a nested field in a document.
       *
       * @param fieldNames A list of field names.
       */
      constructor(...fieldNames: string[]);

      /**
       * Returns a special sentinel FieldPath to refer to the ID of a document.
       * It can be used in queries to sort or filter by the document ID.
       */
      static documentId(): FieldPath;
    }

    export class FieldValue {
      constructor(type: firestoreNamespace.FieldValueType, value: any);

      static serverTimestamp: () => "SERVER_TIMESTAMP";
      static delete: () => "DELETE_FIELD";
      static arrayUnion: (...elements: any[]) => FieldValue;
      static arrayRemove: (...elements: any[]) => FieldValue;
      static increment: (n: number) => FieldValue;
    }

    function collection(collectionPath: string): firestoreNamespace.CollectionReference;

    function collectionGroup(id: string): firestoreNamespace.CollectionGroup;

    function doc(
      collectionPath: string,
      documentPath?: string
    ): firestoreNamespace.DocumentReference;

    function docRef(documentPath: string): firestoreNamespace.DocumentReference;

    function add(
      collectionPath: string,
      documentData: any
    ): Promise<firestoreNamespace.DocumentReference>;

    function set(
      collectionPath: string,
      documentPath: string,
      document: any,
      options?: any
    ): Promise<void>;

    function getCollection(
      collectionPath: string,
      options?: firestoreNamespace.GetOptions
    ): Promise<firestoreNamespace.QuerySnapshot>;

    function getDocument(
      collectionPath: string,
      documentPath: string,
      options?: firestoreNamespace.GetOptions
    ): Promise<firestoreNamespace.DocumentSnapshot>;

    function update(
      collectionPath: string,
      documentPath: string,
      document: any
    ): Promise<void>;

    function runTransaction(
      updateFunction: (transaction: firestoreNamespace.Transaction) => Promise<any>
    ): Promise<void>;

    function batch(): firestoreNamespace.WriteBatch;

    function clearPersistence(): Promise<void>;

    export function GeoPoint(latitude: number, longitude: number): firestoreNamespace.GeoPoint;

    /**
     * Specifies custom settings to be used to configure the `Firestore`
     * instance. Must be set before invoking any other methods.
     *
     * @param settings The settings to use.
     */
    export function settings(settings: firestoreNamespace.Settings): void;

  }
}

// Reexport at top level with correct names for other files to consume types from
export { firestoreNamespace as firestore }
export { functionsNamespace as firebaseFunctions }
